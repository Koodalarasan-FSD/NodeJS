// NodeJS - NodeJS Tutorial - https://www.youtube.com/playlist?list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY
// NodeJS Tutorial - ECMAScript - https://www.youtube.com/watch?v=HXpPKhWOkAs&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=2&pp=iAQB
// NodeJS Tutorial - Chrome's V8 Engine - https://www.youtube.com/watch?v=2mWb7j1A3c8&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=3&pp=iAQB
// NodeJS Tutorial - JavaScript Runtime - https://www.youtube.com/watch?v=BFHUfKtoNkw&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=4&pp=iAQB
// NodeJS Tutorial - What is Node.js? - https://www.youtube.com/watch?v=XQT6XiJt4DE&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=5&pp=iAQB
// NodeJS Tutorial - Hello World - https://www.youtube.com/watch?v=tt1R-DEhvxg&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=6&pp=iAQB 
// NodeJS Tutorial - Browser vs NodeJS - https://www.youtube.com/watch?v=sl-5haKNXGE&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=7&pp=iAQB
// NodeJS Tutorial - Modules - https://www.youtube.com/watch?v=uatPQZVnng4&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=8&pp=iAQB
// NodeJS Tutorial - Local Modules - https://www.youtube.com/watch?v=4gWoKrwGui4&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=9
// NodeJS Tutorial - Modules Exports -  https://www.youtube.com/watch?v=hvOrwICaEJY&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=10
// NodeJS Tutorial - Module Scope - https://www.youtube.com/watch?v=RR5zEGU7TqY&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=11&pp=iAQB
// NodeJS Tutorial - Module Wrapper - https://www.youtube.com/watch?v=ce90lLhDI_Y&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=12&pp=iAQB
// NodeJS Tutorial - Module Caching - https://www.youtube.com/watch?v=JQfOtwfDohY&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=13&pp=iAQB
// NodeJS Tutorial - Import Export Patterns - https://www.youtube.com/watch?v=F_GmxjP80so&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=14&pp=iAQB
// NodeJS Tutorial - Importing JSON and Watch Mode - https://www.youtube.com/watch?v=Es7SzBBc6qE&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=17&pp=iAQB
// NodeJS Tutorial - Built-in Modules - https://www.youtube.com/watch?v=kRG8QpOKZE4&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=18&pp=iAQB
// NodeJS Tutorial - Path Modules - https://www.youtube.com/watch?v=p995SdRXw_E&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=19&pp=iAQB
// NodeJS Tutorial - Callback Patterns - https://www.youtube.com/watch?v=z03tYranyWs&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=20&pp=iAQB 
// NodeJS Tutorial - Events Module - https://www.youtube.com/watch?v=Su0-Y9coU3s&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=21&pp=iAQB
// NodeJS Tutorial - Extending from EventEmitter - https://www.youtube.com/watch?v=UK2uQjgsoI4&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=22&pp=iAQB
// NodeJS Tutorial - Character Sets and Encoding - https://www.youtube.com/watch?v=0LYXkL0pr1M&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=23&pp=iAQB
// NodeJS Tutorial - Streams and Buffers - https://www.youtube.com/watch?v=br8VB99qPzE&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=24&pp=iAQB
// NodeJS Tutorial - Asynchronous JavaScript - https://www.youtube.com/watch?v=QvIC2z8ADtU&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=25&pp=iAQB
// NodeJS Tutorial - fs Module - https://www.youtube.com/watch?v=Z_p1yFGS0Ak&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=26&pp=iAQB
// NodeJS Tutorial - fs Promise Module - https://www.youtube.com/watch?v=wG2-vF4QyZ0&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=27&pp=iAQB
// NodeJS Tutorial - Streams - https://www.youtube.com/watch?v=qnzC6vpBuxw&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=28&pp=iAQB
// NodeJS Tutorial - Pipes - https://www.youtube.com/watch?v=ej79ByltLOI&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=29&pp=iAQB
// NodeJS Tutorial - HTTP Module - https://www.youtube.com/watch?v=3Z-pAgra-tw&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=30&pp=iAQB
// NodeJS Tutorial - Creating a Node Server - https://www.youtube.com/watch?v=x1cEbRIrOu4&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=31&pp=iAQB 
// NodeJS Tutorial - JSON Response - https://www.youtube.com/watch?v=eTXEL921gT4&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=32&pp=iAQB
// NodeJS Tutorial - HTML Response - https://www.youtube.com/watch?v=50YtINv8Y-o&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=33&pp=iAQB 
// NodeJS Tutorial - HTML Template - https://www.youtube.com/watch?v=osX3gNkRlK0&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=34&pp=iAQB 
// NodeJS Tutorial - Web Framework - https://www.youtube.com/watch?v=_eeZQwPqteM&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=36&pp=iAQB 
// NodeJS Tutorial - libuv - https://www.youtube.com/watch?v=mVx_PzR9SPo&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=38&pp=iAQB
// NodeJS Tutorial - Event Loop - https://www.youtube.com/watch?v=L18RHG2DwwA&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=42&pp=iAQB
// NodeJS Tutorial - Deploying Node.js App - https://www.youtube.com/watch?v=yln_CffenYw&list=PLC3y8-rFHvwh8shCMHFA5kWxD9PaPwxaY&index=63

/*
What is NodeJS?
NodeJS is an open-source, cross-platform, JavaScript runtime environment.
OpenSource - source code is publicly available for sharing and modification.
Cross Platform - Available on Windows, Mac and Linux.
JavaScript runtime environment - provides all the necessary components in order to use and run a JavaScript 
                                 Program outside the browser.

- Build end-to-end JavaScript applications.
- A number of major companies like LinkedIn, Netflix, PayPal have all migrated from other backend technologies
  to Node.js.
- It has Huge Community Support.

ECMAScript- 
1)ECMA-262 is the language specification.
2)ECMAScript is the language that implements ECMA-262.
3)JavaScript is basically ECMAScript at its core but builds on top of that

JavaScript code we write cannot be understood by the computer. A JavaScript Engine is a program that 
converts javascript code that developers write into machine code that allows a computer to perform specific
tasks.
JavaScript Engines are typically developed by web browsers vendor
- V8 - OpenSource JavaScript Engine developed by Google for Chrome.
- SpiderMonkey - The JavaScript Engine powering Mozilla Firefox.
- JavaScriptCore - OpenSource JavaScript Engine developed by Apple for Safari.
- Chakra - A JavaScript Engine for the original Microsoft Edge(The Latest version of edge uses V8).

JavaScript runtime is an environment which provides all the necessary components in order to use and 
run a JavaScript Program.
Every browser has a JavaScript Engine.
A JavaScript Engine is one component in the JavaScript Runtime.

What can you build with Node.js?
1)Traditional Websites.
2)Backend Services like APIs
3)Real-time Applications
4)Streaming Services
5)CLI tools
6)Multiplayer games

Node.js allows you to build complex and powerful applications. It is not language and framework, 
it's runtime environment and has capable of executingJavaScript Code outside a browser.

Node REPL - R for Read, E for Evaluate, P for Print, L for Loop.

In the browser, we don't have all the nice APIs that Node.js provides through its modules. For ex: the file
system access functionality.  With Node.js, you control the environment.

The 'require()' function in Node.js is used to import modules. It loads the module by file path and 
returns the exports object of the module.

*/

console.log("Hello World from index.js")

const addFn = require('./add.js')  //We can Import Modules by using "require" function
const sum = addFn(1, 2);
console.log(sum)
const sum2 = addFn(2, 5);
console.log(sum2)

require('./batman.js')
require('./superman.js')

const superHero = require('./super-hero.js')
console.log(superHero.getName());
superHero.setName("Batman");
console.log((superHero.getName()));
const newsuperHero = require('./super-hero.js')
console.log(newsuperHero.getName());

// Import Export Patterns
const math = require('./math.js');
const { add, subtract } = math;
console.log(add(2, 3));
console.log(subtract(2, 3));

// Importing JSON and Watch Mode
// JSON - JavaScript Object Notation - A data interchange format commonly used with web browsers.
const data = require('./data.json')
console.log(data)
console.log(data.name)

/*
Built-in Modules:
    - Modules that Node.js ships with.
    - Also referred to as a core modules.
    - Import the module before you can use it.

There are several types of Built-in Modules in it but mainly we can some important modules such as,
1)path
2)events
3)fs
4)stream
5)http

*/

/* Path Modules -The path module provides utilities for working with file and directory paths.
const path = require("node:path"); // or as const path = require("path");
console.log(__filename);  // Returns filename with path
console.log(__dirname);   // Returns foldername with path
console.log(path.basename(__filename));  // Returns filename.
console.log(path.basename(__dirname));   // Returns foldername.
console.log(path.extname(__filename));  // Returns extension of filename.
console.log(path.extname(__dirname));   // Returns empty string as extension of foldername.
console.log(path.parse(__filename));  // Returns some properties represent significant element of path.
console.log(path.format(path.extname(__filename)));  // Returns path of filename.
console.log(path.isAbsolute(__filename));//By checking path of filename is absolute or not and returns true or false.
console.log(path.isAbsolute('./data.json'));//By checking path of data.json is absolute or not and returns true or false.
console.log(path.join("folder1","folder2","index.js")) //It will used to gives/join path ex:returns as folder1/folder2/index.js
console.log(path.join("/folder1","folder2","index.js"))
console.log(path.join("/folder1","//folder2","index.js"))
console.log(path.join("/folder1","//folder2","../index.js"))
console.log(path.join(__dirname,"data.json"));
console.log(path.resolve("folder1","folder2","index.js")) //It will used to gives/join path with absolute path ex:returns as Aasva/NodeJS/folder1/folder2/index.js
console.log(path.resolve("/folder1","folder2","index.js"))
console.log(path.resolve("/folder1","//folder2","index.js"))
console.log(path.resolve("/folder1","//folder2","../index.js"))
console.log(path.resolve(__dirname,"data.json"));
*/

/*
Callback:
- In JavaScript, functions are first class objects.
- A function can be passed as an argument to a function.
- A function can also be returned as values from other functions.

A function can be passed as an argument to a function is called callback function.
Types of Callback:
1)Synchoronous Callback
2)Asynchoronous Callback
Synchoronous Callback:
- A callback which is executed immediately is called a Synchoronous Callback.
Asynchoronous Callback:
- A callback that is often used to continue or resume code execution after an asynchoronous operation has
completed.
- Callbacks are used to delay the execution of a function until a particular time or event has occurred.
- In Node.js have an asynchoronous nature to prevent blocking of execution.
- Ex: reading data from a file, fetching data from a database or handling a network request.

*/
function greet(name) {
  console.log(`Hello ${name}`);
}
function greetVishwas(greetFn) {
  const name = "Vishwas";
  greetFn(name);
}
greetVishwas(greet);

/*
Events Module:
- The events module allows us to work with events in Node.js.
- An event is an action or an occurrence that has happened in our application that we can respond to.
- Using the events module, we can dispatch our own custom events and respond to those custom events in a 
  non-blocker manner.
*/
// Events Module:
const EventEmitter = require("events");
const emitter = new EventEmitter();
emitter.on("order-pizza", (size, topping) => {
  console.log(`Order received! Baking a ${size} pizza with ${topping}.`);
});
emitter.on("order-pizza", (size) => {
  if (size === "large") {
    console.log("Serving Complimentary Drink!")
  }
});
console.log("Do work before event occurs in the system")
emitter.emit("order-pizza", "large", "mushroom");


/*
// Extending from EventEmitter
const PizzaShop = require('./pizza-shop.js');
const DrinkMachine = require('./drink-machine.js');
const pizzaShop = new PizzaShop();
const drinkMachine = new DrinkMachine();
pizzaShop.on("order", (size, topping) => {
    console.log(`Order received! Baking a ${size} pizza with ${topping}.`);
    drinkMachine.serveDrink(size);
})
pizzaShop.order();
pizzaShop.displayorderNumber();
*/

/* 
Binary Data:
- Computers store and represent data in binary format which is a collection of 0s and 1s.
- Each 0 or 1 is called a binary digit or bit for short.
- To work with a piece of data, a computer needs to convert that data into its binary representation.
Characer in binary format:
- For Ex: V - how can character V can converted into binary format?
- Computers will first convert the character to a number, then convert that number to its binary representation.
- Computers will first convert V to a number that represents V.
- We can findout numberic representation of character by using browser console.
- In Browser Console, type "V".charCodeAt(); and Enter, it will shows accurate numeric representation of character.
- 86 is the numeric representation of the character V.
- It is also called character code.
Character Set:
- Character Sets are predefined lists of characters represented by numbers.
- Popular character sets - Unicode and ASCII.
- Unicode character set dictates that 86 should represent character V.
Character Encoding:
- Character Encoding dictates how to represent a number in a character set as binary data before it can be
  stored in a computer.
- It dictates how many bits to use to represent the number.
- Example of a character encoding system is UTF-8.
- UTF-8 states that character should be encoded in bytes(8 bits).
- Eight 1s or 0s should be used to represent the code of any character in binary.
- 4 => 100 => 00000100
- V => 86  => 01010110
- Similiar guidelines also exist on how images and videos should be encoded and stored in binary format.
*/

/*
Streams:
- A Stream is a sequence of data that is being moved from one point to another point over time.
- Ex: a stream of data over the internet being moved from one computer to another 
                                    (or)
      a stream of data being transferred from one file to another within the same computer.
- Process streams of data in chunks as they arrive instead of waiting for the entire data to be available 
  before processing.
- Ex: watching a video on YouTube.
- The data arrives in chunks and you watch in chunks while the rest of the data arrives over time.
- Ex: transferring file contents from fileA to fileB.
- The contents arrive in chunks and you transfer in chunks while the remaining contents arrives over time.
- Prevents unnecessary data downloads and memory usage.
- Stream is infact a built-in node module that inherits from the event emitter class.
Buffers:
- Area which data wait is nothing but the buffer.
- Node.js cannot control the pace at which data arrives in the stream.
- It can only decide when is the right time to send the data for processing.
- If there is data already processed or too little data to process, Node puts the arriving data in a buffer.
- It is an intentionally small area that Node maintains in the runtime to process a stream of data.
- Ex: streaming a video online
- If your internet connection is fast enough, the speed of the stream will be fast enough to instantly fill up
  the buffer and send it out for processing.
- That will repeat till the stream is finished.
- If your connection is slow, after processing the first chunk of data that arrived, the video player will
  display a loading spinner which indicates it is waiting for more data to arrive.
- Once the buffer is filled up and the data is processed, the video player shows the video.
- While the video is playing, more data will continue to arrive and wait in the buffer.

*/
// Buffer:
const buffer = new Buffer.from("Koodal");
console.log(buffer.toString());
console.log(buffer);
console.log(buffer.toJSON());

/*
Asynchronous JavaScript:
JavaScript is a synchronous, blocking, single-threaded language.
Sample Program:
    function A(){
        console.log('A')
    }
    function B(){
        console.log('B')
    }
    A()
    B()
    ->Logs A and then B
Synchronous:
- If we have two functions which log messages to the console, code executes top down, with only one line 
  executing at any given time.
Blocking:
- No matter how long a previous process takes, the subsequent processes won't kick off until the former is 
  completed.
- Web app runs in a browser and it executes an intensive chunk of code without returning control to the browser,
  the browser can appear to be frozen.
Single-threaded:
- A thread is simply a process that your javascript program can use to run a task.
- Each thread can only do one task at a time.
- JavaScript has just the one thread called the main thread for executing any code.
Problems with synchronous, blocking, single-threaded model of JavaScript.
Sample Program:
    let response=fetchDataFromDB('endpoint')
    displayDataFromDB(response)
- fetchDataFromDB('endpoint') could take 1 second or even more.
- During that time, we can't run any further code.
- JavaScript, if it simply proceeds to the next line without waiting, we have an error because data is not 
  what we expect it to be. 

- Just JavaScript is not enough.
- We need new pieces which are outside of JavaScript to help us write asynchronous code.
- For Front-end, this is where web browsers come into play. For back-end, this is where Node.js comes into play.
- Web browsers and Node.js defines functions and APIs that allow us to register functions that should not be
  executed synchronously, and should instead be invoked asynchronously when some kind of event occurs.
- For ex; that could be the passage of time(setTimeout or setInterval), the user's interaction with the mouse
  (addEventListener), data being read from a file system or the arrival of data over the network(callbacks,Promises,
  async-await)
- You can let your code do several things at the same time without stopping or blocking your main thread.
 
*/


//fs Module - File System Module
const fs = require('fs')
// First Method
const filecontents = fs.readFileSync('./file.txt'); // It returns binary data of texts in file
console.log(filecontents);
const filecontents1 = fs.readFileSync('./file.txt', 'utf-8'); // It returns as text which is in text file.
console.log(filecontents1);
// Second Method
fs.readFile('./file.txt', 'utf-8', (error, data) => {
  if (error) {
    console.log(error);
  }
  else {
    console.log(data);
  }
})
/*
// Third Method
fs.writeFileSync('./greet.txt','Hello World'); // It will create a new file with content written in the coding.
*/
fs.writeFile('./greet.txt', "Hello World!", { flag: 'a' }, (err) => { // It will create a new file or overwrite(append) with content
  if (err) {
    console.log(err);
  }
  else {
    console.log("File Written");
  }
})

/*
// fs Promise Module
const fileread = require('fs/promises');
fs.readFile('file.txt', 'utf-8')
    .then((data) => console.log(data))
    .catch((error) => console.log(error));

async function readFile() {
    try {
        const data = await fs.readFile('file.txt', 'utf-8');
        console.log(data);
    } catch (err) {
        console.log(err);
    }
}
readFile();
*/


// Streams, Pipes
/* 
Readable streams from which data can be read. Ex: Reading from a file as readable stream.
Writable streams to which we can write data. Ex: Writing to a file as wriable stream.
Duplex streams that are both Readable and Writable. Ex: Sockets as a duplex stream.
Transform streams that can modify or transform the data as it is written and read.
Ex: File compression where you can write compressed data and read de-compressed data to and from a file as a
transform stream.
*/
const filecontentall = require('fs');
// Reading file as text using Stream
const readableStream = fs.createReadStream("./file.txt", {
  encoding: 'utf-8',
});

const writeableStream = fs.createWriteStream("./file2.txt");
/* // Write using Stream
readableStream.on("data", (chunk) => {
  console.log(chunk);
  writeableStream.write(chunk);
})
*/

// Write using Pipes
readableStream.pipe(writeableStream);


/*
HTTP:
How the web works:
- Computers connected to the internet are called clients and servers.
- Clients are internet-connected devices such as computers or mobile phones along with web-accessing software
  available on those devices such as web browser.
- Servers on the other hand are computers that store web pages, sites or apps.
HTTP:
- HyperText Transfer Protocol
- A protocol that defines a format for clients and servers to speak to each other.
- The client sends an HTTP request and the server responds with an HTTP response.
HTTP and Node:
- We can create a web server using Node.js.
- Node.js has access to operating system functionality like networking.
- Node has an event loop to run tasks asynchronously and is perfect for creating web servers that can
  simultaneously handle large volumes of requests.
- The node server we create should still respect the HTTP format.
- The HTTP module allow creation of web servers that can transfer data over HTTP. 
*/

// Creating a Node Server using HTTP Module & Receiving JSON Response, HTML Response.
const http = require('http');
const filesystem = require('fs'); // fs module used inorder to read html file.

const server = http.createServer((req, res) => {

  /*
  const superHeroes = {
    firstName: 'Bruce',
    lastName: 'Wayne'
  };
  */
  const name = "Koodalarasan";
  res.writeHead(200, { 'Content-Type': 'text/html' });

  /*
  // Both reading(index.html) & response using Stream to achieve in single line.
  filesystem.createReadStream(__dirname + '/index.html').pipe(res);
  */

  //                  (or)

  // reading index.html using readFileSync
  let html = filesystem.readFileSync('./index.html', 'utf-8');
  html = html.replace("{{name}}", name);
  res.end(html);
  // res.end(JSON.stringify(superHeroes)); // If you use these response then make(write) above Content-Type as 'application/json'.
  // res.end("Hello World!"); // If you use these response then make(write) above Content-Type as 'text/plain'.

});

server.listen(3000, () => {
  console.log("Server running on port 3000");
});                                             // Please type http://localhost:3000/ on browser.


/*

Web Framework:
- A Framework simply abstracts all the lower level code allowing you to focus on the requirements than the
  code itself.
- For example: Angular, React, Vue are all framework/libraries that help you build UI without having to rely
  on the lower level DOM API in JavaScript.
- There are frameworks to build web or mobile applications without having to rely on the HTTP module in node.js
- Ex: express, nest, hapi, koa and sails.
- They build on top of the HTTP module making it easier for you to implement all the features.

*/

/*

libuv:
libuv is a cross platform open source library written in C language.
It handles asynchronous non-blocking operations in Node.js
It mainly use two features such as Thread pool, Event loop.

*/

/*

Event Loop:
  - It is a C Program and is part of libuv.
  - A design pattern that orchestrates or co-ordinates the execution of synchronous and asynchronous code in
    Node.js.

Async Code Execution:
  - JavaScript is a synchronous, blocking, single-threaded language.
  - To make async programming possible, we need the help of libuv.

Event Loop  - Execution Order:
  - User written synchronous JavaScript code takes priority over async code that the runtime would like to
    execute.
  - Only after the call stack is empty, the event loop comes into picture.
*/